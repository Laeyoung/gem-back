#!/usr/bin/env tsx

/**
 * Generate TypeScript code from fetched model data
 * Usage: tsx scripts/generate-models.ts
 * Requires: scripts/models-data.json (generated by fetch-models.ts)
 */

import * as fs from 'fs';
import * as path from 'path';
import type { ModelMetadata, ModelClassification, ProcessedModel } from './types';

const MODELS_DATA_FILE = path.join(__dirname, 'models-data.json');
const TYPES_OUTPUT = path.join(__dirname, '../src/types/models.ts');
const CONFIG_OUTPUT = path.join(__dirname, '../src/config/models.ts');

/**
 * Classify model based on name
 */
function classifyModel(modelName: string): ModelClassification {
  const lower = modelName.toLowerCase();
  if (lower.includes('preview') || lower.includes('-exp-')) {
    return 'preview';
  }
  if (lower.includes('experimental') || lower.includes('-exp')) {
    return 'experimental';
  }
  return 'stable';
}

/**
 * Extract version number from model name
 * Returns [major, minor] or [0, 0] if not found
 */
function extractVersion(modelName: string): [number, number] {
  const match = modelName.match(/gemini-(\d+)\.(\d+)/);
  if (match) {
    return [parseInt(match[1]), parseInt(match[2])];
  }
  return [0, 0];
}

/**
 * Calculate priority for model (lower = higher priority)
 */
function calculatePriority(modelName: string, classification: ModelClassification): number {
  const [major, minor] = extractVersion(modelName);

  // Base priority by version
  let priority = 0;

  // Gemini 3.x = 0-99
  if (major === 3) {
    priority = 0;
  }
  // Gemini 2.x = 100-199
  else if (major === 2) {
    if (minor === 5) priority = 100; // 2.5
    else if (minor === 0) priority = 200; // 2.0
    else priority = 150; // 2.x other
  }
  // Older versions = 300+
  else {
    priority = 300;
  }

  // Add penalty for model variant
  if (modelName.includes('-lite')) priority += 10;
  else if (modelName.includes('-pro')) priority += 5;

  // Add penalty for stability
  if (classification === 'preview') priority += 1000;
  else if (classification === 'experimental') priority += 2000;

  return priority;
}

/**
 * Process models and sort by priority
 */
function processModels(models: ModelMetadata[]): ProcessedModel[] {
  return models
    .map((model) => {
      const classification = classifyModel(model.name);
      const priority = calculatePriority(model.name, classification);

      return {
        name: model.name,
        displayName: model.displayName,
        description: model.description || '',
        classification,
        priority,
        maxTokens: model.outputTokenLimit,
        // Use conservative defaults for rate limits
        rpm: 15,
        rpd: 1500,
      };
    })
    .sort((a, b) => a.priority - b.priority);
}

/**
 * Generate src/types/models.ts content
 */
function generateTypesFile(models: ProcessedModel[]): string {
  const stableModels = models.filter((m) => m.classification === 'stable');

  // Generate union type
  const unionType = models
    .map((m) => {
      const comment =
        m.classification !== 'stable' ? `  /** ‚ö†Ô∏è ${m.classification.toUpperCase()} - ${m.displayName} */\n` : '';
      return `${comment}  | '${m.name}'`;
    })
    .join('\n');

  // Generate DEFAULT_FALLBACK_ORDER (stable models only)
  const defaultFallback = stableModels.map((m) => `  '${m.name}',`).join('\n');

  // Generate ALL_MODELS
  const allModels = models.map((m) => `  '${m.name}',`).join('\n');

  return `// AUTO-GENERATED FILE - DO NOT EDIT MANUALLY
// Generated at: ${new Date().toISOString()}
// Source: Gemini API v1beta/models
// Generator: scripts/generate-models.ts

/**
 * Supported Gemini model identifiers
 */
export type GeminiModel =
${unionType};

/**
 * Default fallback order for stable models
 * Preview and experimental models must be explicitly specified
 */
export const DEFAULT_FALLBACK_ORDER: GeminiModel[] = [
${defaultFallback}
];

/**
 * All supported models (including preview and experimental)
 */
export const ALL_MODELS: GeminiModel[] = [
${allModels}
];
`;
}

/**
 * Generate src/config/models.ts content
 */
function generateConfigFile(models: ProcessedModel[]): string {
  // Generate MODEL_PRIORITY
  const priorityEntries = models.map((m) => `  '${m.name}': ${m.priority},`).join('\n');

  // Generate MODEL_INFO
  const infoEntries = models
    .map((m) => {
      const desc = m.description || `${m.displayName} model`;
      return `  '${m.name}': {
    name: '${m.displayName}',
    description: '${desc}',
    maxTokens: ${m.maxTokens},
  },`;
    })
    .join('\n');

  return `// AUTO-GENERATED FILE - DO NOT EDIT MANUALLY
// Generated at: ${new Date().toISOString()}
// Source: Gemini API v1beta/models
// Generator: scripts/generate-models.ts

import type { GeminiModel } from '../types/models';

/**
 * Model priority (lower number = higher priority in fallback order)
 * Used internally for intelligent fallback selection
 */
export const MODEL_PRIORITY: Record<GeminiModel, number> = {
${priorityEntries}
};

/**
 * Model metadata and capabilities
 */
export const MODEL_INFO: Record<
  GeminiModel,
  {
    name: string;
    description: string;
    maxTokens: number;
  }
> = {
${infoEntries}
};
`;
}

/**
 * Detect changes between old and new generated files
 */
function detectChanges(oldContent: string, newContent: string): boolean {
  // Strip timestamps for comparison
  const stripTimestamp = (content: string) =>
    content.replace(/Generated at: [^\n]+/, 'Generated at: TIMESTAMP');

  return stripTimestamp(oldContent) !== stripTimestamp(newContent);
}

/**
 * Main execution
 */
async function main() {
  try {
    console.log('üîß Generating TypeScript code from model data...\n');

    // Load models data
    if (!fs.existsSync(MODELS_DATA_FILE)) {
      throw new Error(
        `Models data file not found: ${MODELS_DATA_FILE}\n` +
          'Run "npm run fetch-models" first to fetch model data.'
      );
    }

    const data = JSON.parse(fs.readFileSync(MODELS_DATA_FILE, 'utf-8'));
    const models = data.models as ModelMetadata[];

    if (!models || models.length === 0) {
      throw new Error('No models found in data file');
    }

    console.log(`üìä Processing ${models.length} models...`);

    // Process and sort models
    const processedModels = processModels(models);

    const stableCount = processedModels.filter((m) => m.classification === 'stable').length;
    const previewCount = processedModels.filter((m) => m.classification === 'preview').length;
    const expCount = processedModels.filter((m) => m.classification === 'experimental').length;

    console.log(`   - ${stableCount} stable models`);
    console.log(`   - ${previewCount} preview models`);
    console.log(`   - ${expCount} experimental models\n`);

    // Generate files
    const typesContent = generateTypesFile(processedModels);
    const configContent = generateConfigFile(processedModels);

    // Detect changes
    let typesChanged = true;
    let configChanged = true;

    if (fs.existsSync(TYPES_OUTPUT)) {
      const oldTypes = fs.readFileSync(TYPES_OUTPUT, 'utf-8');
      typesChanged = detectChanges(oldTypes, typesContent);
    }

    if (fs.existsSync(CONFIG_OUTPUT)) {
      const oldConfig = fs.readFileSync(CONFIG_OUTPUT, 'utf-8');
      configChanged = detectChanges(oldConfig, configContent);
    }

    // Write files
    fs.writeFileSync(TYPES_OUTPUT, typesContent);
    console.log(`${typesChanged ? '‚ú®' : '‚úì'} Generated ${TYPES_OUTPUT} ${typesChanged ? '(changed)' : '(unchanged)'}`);

    fs.writeFileSync(CONFIG_OUTPUT, configContent);
    console.log(`${configChanged ? '‚ú®' : '‚úì'} Generated ${CONFIG_OUTPUT} ${configChanged ? '(changed)' : '(unchanged)'}`);

    if (typesChanged || configChanged) {
      console.log('\nüìù Model list updated:');
      processedModels.forEach((m) => {
        const badge =
          m.classification === 'stable' ? '‚úÖ' : m.classification === 'preview' ? '‚ö†Ô∏è' : 'üß™';
        console.log(`   ${badge} ${m.name} - ${m.displayName} (priority: ${m.priority})`);
      });

      console.log('\nüí° Next steps:');
      console.log('   1. Run "npm run lint:fix" to format generated code');
      console.log('   2. Run "npm test" to ensure tests pass');
      console.log('   3. Review changes with "git diff"');
    } else {
      console.log('\n‚úÖ No changes detected. Model list is up to date.');
    }

  } catch (error) {
    console.error('\n‚ùå Error:', (error as Error).message);
    process.exit(1);
  }
}

main();
